import * as azureStorage from "azure-storage";
import * as intostream from "into-stream";
import * as mongoose from "mongoose";

import { Model } from "mongoose";
import { FileConfig } from "./config";
import { BaseService } from "@timetree/base-service";

import mediaModel, { IMedia } from "./media/media.model";
import MediaModel from "./media/media.model";
export class FileService extends BaseService<IMedia, Model<IMedia>> {
  constructor(model?) {
    super(model ? model : mediaModel);
  }
  // default container
  //
  public async getAllMedia(
    user?,
    criteria?,
    skip?: number,
    limit?: number,
    pagination?: boolean,
    sort?: string
  ) {
    return await super.getAll({
      criteria,
      skip,
      limit,
      pagination,
      sort,
      user
    });
  }

  public async addmedia(
    entity: string,
    id: string,
    file,
    userId: string,
    fileInfo
  ) {
    const model = mongoose.model(entity);
    const doc: any = await model.findOne({ _id: id, deleted: false });
    if (!doc)
      return Promise.reject({
        code: "NOT_FOUND",
        message: `${entity} with id ${id} not found`
      });
    const media = new MediaModel(fileInfo);
    await media.save();
    await this.uploadFile(fileInfo.containerName, fileInfo.blobName, file);
    const docmedia = doc.media || [];
    doc.media = [...docmedia, media._id];
    return await doc.save();
  }
  public async deleteMedia(mediaId: string) {
    const media = await this.model.findOne({ _id: mediaId });
    if (!media)
      return Promise.reject({
        code: "NOT_FOUND",
        message: `Media  with id ${mediaId} not found`
      });
    const blobService = await azureStorage.createBlobService(
      FileConfig.options.connectionString
    );
    return new Promise((resolve, reject) => {
      blobService.deleteBlob(
        media.containerName,
        media.blobName,
        (err, response) => {
          if (err) {
            return reject(err);
          } else {
            return resolve(response);
          }
        }
      );
    });
  }
  public async readFileById(mediaId, stream) {
    const media = await this.model.findOne({ _id: mediaId });
    if (!media)
      return Promise.reject({
        code: "NOT_FOUND",
        message: `Media  with id ${mediaId} not found`
      });
    return await this.readFile(
      media.containerName,
      media.blobName,
      stream,
      media.blobName,
      media.contentType
    );
  }
  public async readFile(
    containerName,
    blobName,
    destinationStream,
    fileName?,
    contentType?
  ) {
    return new Promise(async (resolve, reject) => {
      const blobService = await azureStorage.createBlobService(
        FileConfig.options.connectionString
      );
      blobService
        .createReadStream(containerName, blobName, () => {
          return;
        })
        .on("error", err => {
          return reject(err);
        })
        .once("data", (data, str) => {
          destinationStream.setHeader(
            "Content-Disposition",
            `attachment; filename=${fileName}`
          );
          destinationStream.setHeader("Content-Type", `${contentType}`);
        })
        .pipe(destinationStream);

      resolve(blobName);
    });
  }

  public async uploadFile(containerName, blobName, data) {
    // data param is generated by multer middleware from request object

    const fileStream = intostream(data.buffer);
    const fileStreamLength = data.buffer.length;
    const blobService = azureStorage.createBlobService(
      FileConfig.options.connectionString
    );
    return new Promise((resolve, reject) => {
      blobService.createBlockBlobFromStream(
        containerName,
        blobName,
        fileStream,
        fileStreamLength,
        async (err, data) => {
          if (err) {
            return reject(err);
          } else {
            return resolve(blobName);
          }
        }
      );
    });
  }
}
export default new FileService();
